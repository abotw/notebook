---
date: 2025-05-06T09:43:00
---

> [!faq]
> 为什么在 `always` 块中赋值必须为 `reg` 类型，且要使用非阻塞型（`<=`）赋值？

这是 Verilog 中非常核心的概念，下面分别解释两个问题：

---

### ✅ 1. **为什么在 `always` 块中赋值必须是 `reg` 类型？**

Verilog 的类型和行为之间有明确的约定：

- 在 **`always` 块中赋值的信号必须是 `reg` 类型**，是因为 `reg` 表示该信号在仿真中需要“存储”某个值。
    
- 在 `always` 块中，Verilog 模拟的是 **时序逻辑**（寄存器行为），也就是说变量的值会在特定时刻更新（如时钟边沿），因此必须是“可存储”的，`reg` 类型正是这种**寄存器行为**的抽象。
    

> ⚠️ 注意：`reg` 并不一定表示“寄存器”硬件，而是用于仿真中建模存储行为。

---

### ✅ 2. **为什么要使用非阻塞赋值（`<=`）？**

Verilog 中有两种赋值方式：

- **阻塞赋值（`=`）**：语句会按顺序执行，阻塞后续语句。
    
- **非阻塞赋值（`<=`）**：不会阻塞后续语句，多个赋值“同时生效”，**适合建模时序逻辑**。
    

在时钟触发的 `always @(posedge clk)` 中：

- 用 `<=` 表示信号会在时钟边沿“并行地”更新，符合**实际寄存器的行为**
    
- 若用 `=` 可能会引入顺序依赖，导致错误的电路或仿真结果
    

---

### ✅ 示例说明：

```verilog
// 正确用法：非阻塞赋值
always @(posedge clk) begin
    a <= b;
    b <= a;
end
```

上述表示：**`a` 和 `b` 在同一个时钟边沿同时交换值**。

而如果用阻塞赋值：

```verilog
// 错误或非预期行为
always @(posedge clk) begin
    a = b;
    b = a;
end
```

表示：先把 `b` 赋值给 `a`，再用已经变化后的 `a` 赋值给 `b`，结果两个值都变成 `b`，**与硬件行为不符**。

---

总结：

|特性|阻塞赋值（=）|非阻塞赋值（<=）|
|---|---|---|
|执行顺序|顺序执行|并行更新|
|适用场景|组合逻辑|时序逻辑（推荐）|
|用于 always 块|不推荐（用于组合逻辑）|推荐（用于时序逻辑）|


- [It’s official: Raspberry Pi OS goes 64-bit](https://www.jeffgeerling.com/blog/2022/its-official-raspberry-pi-os-goes-64-bit)
    
- [CS107E: Computer Systems from the Ground Up](http://cs107e.github.io/)
    

## 无符号整型 (unsigned int)

无符号整型只能表示 0 和正数，不可以表示负数。

下图通过**数字轮盘**形象地表示了无符号整型的二进制表示和十进制数字之间的**关系**，以及无符号整型能够表示的数字**范围**：

![[unsigned_int.png]]

## 有符号整型 (signed int)

有符号整型可以表示 0，正数和负数。

既然要表示负数，那么首先需要解决的问题是：如何通过二进制位表示正或负？

目前的解决方案是通过保留一个符号位（sign bit，最高位）来区分正和负，这个位称为**最高有效位** MSB（most significant bit）。

### 原码 （Sign-Magnitude Representation）

在早期计算机设计中，人们希望**直接模仿人类表示正负数的方式**。就像我们在纸上写“+5”或“-5”一样，**用一个符号位（sign bit）表示正负**，剩下的位表示数值大小（magnitude）。  

因此，原码的设计是：

- **最高位（最左边的位）表示符号**：0 表示正数，1 表示负数；
- **剩余位**表示**数值的绝对值**（magnitude）。

比如在8位二进制下：

- +5 的原码是 `00000101`
- -5 的原码是 `10000101`

---

**原码的缺点**（**Disadvantages of Sign-Magnitude Representation**）：

1. **加减运算复杂**：
    - 需要额外判断符号位，如果符号不同，还要做加法变减法等处理，电路设计很麻烦。
2. **存在“正零”和“负零”**（+0 和 -0）：
    - +0 表示为 `00000000`
    - -0 表示为 `10000000`
    - 这导致零有两种表示方式，增加了不必要的复杂性。

### 1s 的补码（One’s Complement）

**反码**（**One’s Complement**）的提出，主要是为了**简化负数的表示**，并且**让减法运算变得更简单**。

在原码（Sign-Magnitude Representation）中，正负数的表示虽然直观，但**做加减法时非常麻烦**，需要针对符号位单独判断处理，导致**加减电路复杂**。

为了解决这个问题，人们提出了**反码表示法（One’s Complement Representation）**，特点是：

- 正数的反码 = 它本身（和原码一样）。
- 负数的反码 = **正数按位取反**（0变1，1变0）。

这样做有什么好处呢？

- **加法运算**可以直接使用统一的加法电路，只需要注意最后的“进位加回末位”（称为**回卷进位**，或**循环进位**，End Around Carry）。
  ![end-around-carry](https://cs102doc.stickmind.com/_images/end-around-carry.png)
- **负数的生成**只需要“按位取反”，操作简单。
- 对应的正负数相加可以得到全为 1 的二进制位。例如 -1 和 1 相加的二进制位是 1111。

---

**但是，反码也有缺点**：

- **还是有两个零**（+0 和 -0）：
    - +0 是 `00000000`
    - -0 是 `11111111`
- 仍然带来了一些麻烦，比如零的判断不统一。

---

总结一下，  **反码**是为了**简化原码加减法的电路设计**，但没有彻底解决“双零”的问题。

---

### 2s 的补码（Two’s Complement）

**补码**（**Two’s Complement**）是在反码（One’s Complement）的基础上进一步改进的，它彻底解决了之前的两个问题：

---

**问题1：加减法复杂？**

- 在补码表示下，**加法和减法都可以直接用统一的加法器完成**，
- 无需再专门处理符号位，也不需要回卷进位（End Around Carry）。
- **负数的补码**是：**先取反码，然后再加1**。  
    （即：负数 = 正数按位取反后再加1）

这样一来，不管是正数加负数，还是负数加正数，或者两个负数相加，**一律只用加法器**，硬件设计非常简单。

---

**问题2：正零和负零？**

- 在补码表示中，**只有一个零**（0000...0000），没有负零了。
- 因为如果你按照补码规则去构造“负0”，
    - 0的按位取反是 `1111...1111`，
    - 再加1，变成 `0000...0000`，
    - 也就是还是普通的零。
- 所以补码自然消除了“双零”问题。

---

**小结一下补码的特点**：

- 正数的补码 = 原码本身。
- 负数的补码 = 正数取反后加1。
- 加减法统一，只需要一个加法器。
- 零唯一。

---

例如，+1 二进制表示为 0001，反转后的结果是 1110，然后再进行加 1 操作得到 1111 用于表示 -1；同样，+2 二进制表示为 0010，反转后的结果是 1101，然后再进行加 1 操作得到 1110 用于表示 -2。

下图通过数字轮盘形象地表示了 2s 的补码表示的有符号整型的二进制表示和十进制数字之间的**关系**，以及有符号整型能够表示的数字**范围**：

![[signed_int.png]]

```c
// 对应的正负数相加的结果依然是 0。
  0101 (+5)         1111  (-1)
+ 1011 (-5)       + 0001  (+1)
  ======            ======
  0000 (0)          0000  (0)
```

```c
// 加法操作逻辑更简单，可以用于任意的正负数组合，不需要循环进位。
  0010 (+2)         0100  (+4)           0100  (+4)
+ 1011 (-5)       - 0101  (+5)  -->>   + 1011  (-5)
  ======            ======               ======
  1101 (-3)         ????  (??)           1111  (-1)
```

> [!NOTE] 小技巧：对于二进制表示的数字，如何快速找到其对应的正/负值？
> 从右向左，找到第一个 1，将左侧剩下的位全部反转即可。
> 例如，+2 的位模式为 00**1**0，那么将第一个 1 左侧所有位反转可以得到 **111**0，即为 -2。

### 移码

**移码**（**Excess-N Notation** 或 **Biased Representation**）出现，  
主要是为了解决**比较大小、排序、逻辑运算**时的麻烦，特别是**浮点数（floating-point numbers）**里的**指数部分（exponent）**需要排序时的问题。

---

### 为什么需要移码？

补码虽然很好，但它在**逻辑比较大小**时不够方便。

- 补码数的二进制大小顺序**不是直接和数学大小顺序对应的**。  
    （比如，补码中负数的二进制值很大，因为最高位是1）
    
- 举例子：8位补码
    
    - -1 是 `11111111`
        
    - +0 是 `00000000`
        
    - 直接比较这两个二进制串，-1 反而看起来“更大”，不符合我们对数值大小的直观理解。
        

在**浮点数的指数比较**时，需要很快地按二进制比较大小，  
为了让**二进制的大小顺序和数学大小顺序一致**，就发明了**移码（Biased Representation）**。

---

### 什么是移码？

移码 = **原数值 + 一个固定的偏移量（bias）**。

通常：

- 选一个偏移量 `bias = 2^(k-1) - 1`，其中 `k` 是指数的位数。 （比如8位移码，bias=127）
    
- 存储时，把实际的数 + bias，然后转成二进制存下来。
    

**例子**（8位移码，bias=127）：

|实际指数|移码表示（实际指数 + 127）|二进制|
|---|---|---|
|-2|125|01111101|
|0|127|01111111|
|+2|129|10000001|

你可以看到，越大的指数对应越大的移码值，而且**直接按二进制就能比较大小**！

---

### 移码解决了什么问题？

1. **比较大小方便**：
    
    - 无需专门区分正负，直接二进制比较大小就可以得出正确结果。
        
2. **简化硬件逻辑**：
    
    - 浮点数运算器只需要简单的比较器，不需要专门考虑负数符号。
        
3. **自然处理负指数**：
    
    - 负数指数通过加偏移量，变成了正数，避免了处理负数的复杂性。
        

---

🌟 小总结：

- **补码**主要为了解决**加减法简单化**的问题；
    
- **移码**主要为了解决**逻辑比较大小方便**的问题，尤其适合**浮点数的指数部分**。
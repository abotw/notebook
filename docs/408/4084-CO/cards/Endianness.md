# 大端 / 小端（Endianness）

## 📌 简介

**大端（Big-endian）**与**小端（Little-endian）**是**多字节数据在内存中存储字节顺序**的方式，主要影响 CPU、内存、网络传输等系统间的数据兼容与解释。

## 🧠 核心要点

|项目|大端（Big-endian）|小端（Little-endian）|
|---|---|---|
|存储顺序|高字节存在低地址（先存高位）|低字节存在低地址（先存低位）|
|示例（0x12345678）|地址0x00=12, 0x01=34, 0x02=56, 0x03=78|地址0x00=78, 0x01=56, 0x02=34, 0x03=12|
|代表体系结构|网络协议（TCP/IP）、Motorola、SPARC 等|Intel x86/x86-64、ARM 默认小端模式|
|编程相关|与类型转换、字节序处理紧密相关|影响跨平台二进制数据的解析|

## 🔍 经典使用场景

### 1. **网络传输中的统一性**

- **网络字节序**规定为**大端格式**，确保不同主机间通信一致性。
    
- 典型 API 示例（C）：
    
    ```c
    uint32_t ip = htonl(0x12345678);  // 主机转网络（小端转大端）
    ```
    

### 2. **调试和内存分析**

- 使用 GDB 或 hexdump 查看内存时，字节序决定数据解释方式。
    
    ```bash
    hexdump -C a.out     # 分析 ELF 文件时需明确字节序
    ```
    

### 3. **文件格式与跨平台**

- 某些格式（如 PNG、WAV、ELF）规定固定字节序解析；
    
- 跨平台二进制文件传输需统一 endian，否则解析错误。
    

### 4. **嵌入式开发中的灵活设置**

- ARM 支持 **小端/大端切换**，需在启动配置中设定；
    
- 编译时需加 `__BYTE_ORDER__` 检测字节序。
    

## 🔗 融会贯通

- **与汇编语言**：加载/存储多字节数据时需考虑字节序差异；
    
- **与结构体对齐（padding）**：不同字节序影响结构体内存布局；
    
- **与网络协议/安全**：错误的字节序处理会导致协议解析失败或安全漏洞；
    
- **与文件系统/存档格式**：如 NTFS（小端）、ISO9660（大端）等。
    

## 💡 小贴士

- 检测主机字节序（C/C++）：
    
    ```c
    union { uint32_t i; char c[4]; } u = {0x01020304};
    printf("%s\n", u.c[0] == 1 ? "Big-endian" : "Little-endian");
    ```
    
- 常用宏函数（C 标准库 `<arpa/inet.h>`）：
    
    - `htonl`, `htons`, `ntohl`, `ntohs` 用于网络编程中字节序转换。
        
- Linux 文件标识字节序（如 ELF 的第六字节）：
    
    - `0x01` 表示小端，`0x02` 表示大端。
        

## 📚 延伸阅读

- 《CSAPP》第 2 章：表示与处理信息（字节序与内存）
    
- RFC 1700：TCP/IP 网络字节序标准
    
- ARM 技术手册：Endian Modes & Configuration
    
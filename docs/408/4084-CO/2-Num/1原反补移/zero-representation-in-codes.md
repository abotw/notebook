
# 零的多种编码表示方式及其本质差异

## 1. 原码与反码中的 0

- 原码（Sign-Magnitude）和反码（One’s Complement）**都有两个零**：
    
    - `+0`：符号位为 0，其余全 0 → `0000`
        
    - `-0`：符号位为 1，其余全 0 → `1000`
        
- 这导致了零的**双重表示**问题，是它们的一大缺陷。
    

---

## 2. 补码中的 0

- 补码（Two’s Complement）**只有一个零**：
    
    - `0000` 表示 0（+0）
        
- 原本用于表示 `-0` 的那一个编码状态（如 `1000`）被用于表示最小负数（例如 -8），使得**编码空间无浪费，计算更统一**。
    

---

## 3. 移码中的 0

- 移码（Biased Representation）用于表示浮点数的**阶码**，其本质是：
    
    $\text{移码} = \text{真值} + \text{偏置值}$
- 通常偏置值为 $2^{n-1}$（n 为位数），因此：
    
    - 当**真值为 0** 时，对应的移码为偏置值。
        
    - 例如：若 n = 4，偏置值为 8，则：
        
        $\text{0 的移码} = 0 + 8 = 8 \quad → \quad 二进制为 1000$

---

## 408 考研相关补充说明

- **“零的表示方式”是 408《计算机组成原理》中非常常见的考点**，重点包括：
    
    - 不同编码方式下，0 的表示是否唯一
        
    - 为什么补码只有一个 0？
        
    - 移码中 0 的表示位置与偏置值的关系（常用于浮点数阶码解码）

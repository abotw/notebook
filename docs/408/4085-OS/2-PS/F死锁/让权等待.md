
# 让权等待

“**让权等待**”（**busy-waiting with relinquishing** 或称为 **relinquishing waiting**）是操作系统中一种进程同步时避免忙等待（busy waiting）的一种策略。

---

## 🔧 一、问题背景：忙等待（Busy Waiting）

在并发程序中，如果一个进程（或线程）想要进入一个临界区（critical section），但此时锁被其他进程占用，它可能会不断地“查看”锁是否释放：

```c
while (lock == 1);  // 忙等待：不断检查锁
```

这段代码就是典型的**忙等待**。它的问题是：**浪费 CPU 时间**。即使进程暂时无法进入临界区，它依然一直占用 CPU，不停循环检查。

---

## 🌱 二、让权等待（Relinquishing Waiting）的概念

“让权等待”是一种改进策略，它的核心思想是：

> 当进程发现自己无法进入临界区时，**主动让出 CPU（yield），进入等待状态或睡眠状态**，这样就不会浪费 CPU 时间。

#### 🚦对比：

|方式|是否浪费 CPU 时间|是否容易实现|响应速度|
|---|---|---|---|
|忙等待|✅ 是|✅ 容易|⚡ 快|
|让权等待|❌ 否|⚠ 稍复杂|🐢 稍慢|

---

## 🧠 三、让权等待的常见实现方式

#### 1. 使用系统调用让出 CPU（如 `sched_yield()`、`sleep()`）

```c
while (lock == 1) {
    sched_yield();  // 主动让出 CPU 给其他进程
}
```

或者让自己稍微“休息”一下：

```c
while (lock == 1) {
    sleep(1);  // 等 1 秒再检查
}
```

这样就不会无谓消耗 CPU。

#### 2. 在内核级同步中，“让权等待”常表现为阻塞等待：

比如使用 **信号量**、**互斥锁（mutex）**、**条件变量**等：

```c
pthread_mutex_lock(&mutex);  // 如果获取不到，会阻塞，进入等待队列
```

这时候当前线程就**让权**，**进入等待队列**，直到锁释放再被唤醒。

---

## 🎯 四、总结

**让权等待** = 当资源不可用时，不死磕（不忙等），**主动暂停自己，让 CPU 去做更有用的事**。

它的意义在于提高系统的**整体资源利用率**，避免 CPU 时间浪费。

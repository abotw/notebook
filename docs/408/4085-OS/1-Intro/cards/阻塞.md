
# 阻塞

## 核心概念

- **阻塞（Blocking）**是指**进程或线程因等待某事件或资源**（如 I/O、信号、锁等）而**暂停执行**，进入 **阻塞状态（Blocked/Waiting）**，直到所等待的条件满足。
    
- 是**进程五状态模型**中的一种常见状态，常与**就绪（Ready）**、**运行（Running）**状态切换配合出现。
    

---

## 常见阻塞场景

|场景|描述|
|---|---|
|I/O 操作|如等待磁盘读写、网络数据到达|
|资源竞争|如等待互斥锁、信号量、临界区等资源的释放|
|进程通信|管道、消息队列、Socket 等机制中的同步等待|
|等待子进程结束|父进程调用 `wait()` 等待子进程退出|
|条件变量等待|线程等待某条件成立再继续运行|

---

## 状态转换示意（简化）

```
            ┌──────────┐
            │ 运行状态 │
            └────┬─────┘
                 ↓
          （请求资源/IO）
                 ↓
            ┌──────────┐
            │ 阻塞状态 │
            └────┬─────┘
       （资源就绪/事件发生）
                 ↓
            ┌──────────┐
            │ 就绪状态 │
            └──────────┘
```

---

## 实用案例

### 1. **read() 系统调用阻塞读**

```c
char buf[100];
read(fd, buf, 100);  // 若无数据可读，进程会被阻塞
```

进程等待数据到达，期间 CPU 可执行其他任务。

### 2. **pthread_mutex_lock**

在多线程程序中，如果一个线程尝试获取已被占用的互斥锁，会**被阻塞**直到锁可用。

### 3. **Socket 编程**

`recv()` 默认是阻塞调用：若无数据到达，线程会一直等待。

---

## 与相关概念对比

|概念|描述|
|---|---|
|阻塞|主动放弃 CPU，等待某事件完成|
|非阻塞|操作立即返回，不管资源是否准备好|
|死锁|多个进程/线程彼此阻塞，永不满足条件|
|忙等（轮询）|不断检查资源状态，CPU 占用率高，效率低|

---

## 与其他垂直领域的融合

|相关领域|关联内容|
|---|---|
|操作系统|状态切换、调度策略、进程通信与同步|
|网络编程|阻塞/非阻塞 Socket，epoll/select/poll 等 I/O 模型|
|并发编程|互斥、信号量、条件变量均可能导致线程阻塞|
|嵌入式系统|为节能常采用阻塞等待外设或事件中断|
|高性能计算|用异步/事件驱动机制减少阻塞，提高吞吐|

---

## 小结

- 阻塞是**操作系统调度机制的重要组成**，能避免进程浪费 CPU。
    
- 合理使用阻塞/非阻塞、同步/异步机制，是高效系统设计的关键。
    

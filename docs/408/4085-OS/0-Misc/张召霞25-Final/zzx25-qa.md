
# (17') 张召霞25-分析题

## 1. Intro: 系统调用 vs. 用户程序 vs. 库函数 (4') *

> (4') 什么是**系统调用**？系统调用与一般**用户程序**和**库函数**有何区别？
> 
> _ch01-24-txdsol-p05_

### 备考

- (1') **系统调用**是OS提供给程序员的**唯一内核级接口**。执行在**内核态**，用于程序请求系统资源、服务。
	- 程序员利用系统调用，在程序层面动态请求、释放系统资源，调用OS中的已有功能来完成与机器硬件的交互。
	- 系统调用像一个“黑盒子”，对程序员屏蔽了OS的具体实现，只提供有关功能。
- 区别
	1. (1') 系统调用：**内核态执行**，通过**中断机制**进入内核来获得系统服务；
	2. (1') 用户程序：**用户态执行**，直接为用户完成功能；
	3. (1') 库函数：不涉及内核切换，封装常用功能到函数库，面向应用开发，便于编程。

### 参考

![](assets/Pasted%20image%2020250529114908.png)

---

[https://stackoverflow.com/questions/29816791/what-is-the-difference-between-system-call-and-library-call](https://stackoverflow.com/questions/29816791/what-is-the-difference-between-system-call-and-library-call)

![](assets/Pasted%20image%2020250604152942.png)

![](assets/Pasted%20image%2020250604153034.png)

---

[https://www.cs.odu.edu/~price/cs471/public_html/spring17/lectures/OSStructures.htm](https://www.cs.odu.edu/~price/cs471/public_html/spring17/lectures/OSStructures.htm)

![](assets/Pasted%20image%2020250604153449.png)

---

[https://userpages.cs.umbc.edu/jtang/archives/cs421.f19/lectures/L03SystemCalls.pdf](https://userpages.cs.umbc.edu/jtang/archives/cs421.f19/lectures/L03SystemCalls.pdf)

![](assets/Pasted%20image%2020250604153544.png)

## 2. PS: 前驱图 (5') *

>(5') 什么是前驱图？请画出下列4条语句的前驱图。
>
>_ch02-01-txdsol-p09_

### 备考

(1') **前驱图（Precedence Graph）** 是一个**有向无环图（DAG，Directed Acyclic Graph）**，用于描述进程间执行的前后关系。

(4') 画图。

### 参考

![](assets/Pasted%20image%2020250531092941.png)

## 3. PS: 进程创建的主要步骤 (4')

> (4') 在创建一个进程时，OS 需要完成的主要工作是什么？
> 
> _ch02-08-txdsol-p10_

### 备考

当OS发现有创建新进程的请求时，主要完成以下工作：

1. (1') **调用进程创建原语**；
    
2. (2') **申请空白PCB**，并填写该进程的控制与管理信息；
    
3. (3') **为进程分配运行所需资源**；
    
4. (4') **将PCB置为就绪状态**，并插入**就绪队列**。

### 参考

![](assets/Pasted%20image%2020250529114821.png)

## 4. PS: Scheduling: 调度选择准则 (4')

> (4') 在选择调度方式和调度算法时，应遵循哪些准则？
> 
> _ch03-08-txdsol-p15_

### 备考

(1') 在设计OS时，调度方式与调度算法的选择取决于**系统类型**与**设计目标**。不同类型的系统（如**批处理系统**、**分时系统**、**实时系统**）适用不同的调度策略。

应遵循的准则包括：

1. (1') **共同目标**：资源利用率高、公平性与平衡性、策略强制执行；
    
2. (1') **批处理系统**：平均周转时间短、系统吞吐量大、处理机利用率高；
    
3. (1') **分时系统**：响应时间快、负载均衡；
    
4. (1') **实时系统**：保证截止时间、可预测性。

### 参考

![](assets/Pasted%20image%2020250529114428.png)

## 5. PS: PV: 信号量 (2') *

> (2') 若信号量的初值为 2，当前值为 -1，则表示有多少个等待进程？请分析。
> 
> _ch04-13-txdsol-p25_

- **结论**：若当前信号量值为 -1，则表示有 1 个进程在等待资源（被阻塞）。
- 分析
	- 信号量的初值表示系统中资源的数目，每次执行 P 操作（`P()`）即代表一个进程请求一个单位的资源，信号量会减 1。当信号量的值小于 0 时，表示资源已被分配完，后续的请求进程将被阻塞，加入阻塞/等待队列。
	- 因此，**当信号量小于 0 时，其绝对值表示当前阻塞队列中进程的个数**。题目中信号量当前值为 -1，说明有 **1 个等待进程**。

![](assets/Pasted%20image%2020250529114010.png)

### 总结

- **信号量（Semaphore）**：用于进程同步和互斥的计数器变量。
    
- **初值**：表示系统中可用资源的总数。
    
- **P 操作（也称 wait 或 down）**：
    
    - 对信号量减 1。
        
    - 若减后结果 **<** 0，说明无可用资源，当前进程阻塞，进入阻塞队列。
        
- **V 操作（也称 signal 或 up）**：
    
    - 对信号量加 1。
        
    - 若结果 ≤ 0，唤醒阻塞队列中的一个进程。
        
- **信号量当前值的含义**：
    
    - ≥ 0：表示仍有空闲资源。
        
    - < 0：其绝对值表示阻塞进程的数量。


## 6. Mem: Page/Segment: 分页与分段在信息共享与保护方面的比较 (4')

> (4') 为什么说分段系统较分页系统更易实现信息共享与保护？
> 
> _ch05-10-txdsol-p32_

**结论**：分段系统由于其逻辑清晰、管理粒度较大、地址连续，**更易于实现信息的共享与保护**。

分析：

1. **分页系统** 中，每个页是分散存储的，内存是按固定大小划分的页来管理的。若要实现信息共享与保护，需要确保各进程共享的页能够一一对应，这通常需要建立**大量的页表项**来管理映射关系，增加系统负担。
    
2. **分段系统** 中，每个段具有逻辑意义，如代码段、数据段等，每段地址从 **0 开始**，采用连续的地址空间。在实现共享与保护时，只需为共享的程序或数据分配一个段，并在各进程的段表中设置该段的表项即可。这样可以**直接通过段表项实现共享与保护**，更为简便。

![](assets/Pasted%20image%2020250529113712.png)
    
---

### 总结：分页与分段在信息共享与保护方面的比较

|比较维度|分页系统|分段系统|
|---|---|---|
|地址结构|线性划分为固定大小的页|逻辑划分为有意义的段|
|地址连续性|页在内存中不一定连续|每段是连续的地址空间|
|信息共享实现|需要多个页表项进行映射|仅需一个共享段的段表项|
|信息保护实现|通过页表权限控制，但粒度较细，不易管理|段有明确边界，易于设置访问权限|
|管理复杂性|高，需要维护大量页表|较低，段的逻辑意义有助管理|

## 7. Mem: Segment: 请求分段存储管理的硬件支持 (3') *

> 为了实现请求分段存储管理，应在系统中增加配置哪些硬件机构？
> 
> _ch06-12-txdsol-p39_

1. **段表机制**：用于记录每个段的起始地址（基址）和长度（段限），支持段的地址转换和访问控制。
    
2. **缺段中断机构**：当程序访问的段尚未装入内存时，触发缺段中断，由操作系统负责调入所需段。
    
3. **地址转换机构**：负责将用户提供的逻辑地址（段号 + 段内偏移）转换为物理地址。

![](assets/Pasted%20image%2020250604155601.png)

---

![](assets/Pasted%20image%2020250529113509.png)

### 总结

请求分段（**Demand Segmentation**）是一种将进程的各个段按需调入内存的管理方式，为实现该功能，需要如下硬件支持：

| 硬件机构       | 作用说明                                                            |
| ---------- | --------------------------------------------------------------- |
| **段表机制**   | 存储每个段的基址（base）和段长（limit）；进行地址转换（address translation）和权限检查（访问控制） |
| **缺段中断机构** | 段不在内存（mem）时自动触发中断（INT），交由OS处理装入                                 |
| **地址转换机构** | 实现从 LA 逻辑地址（段号+段内地址）到 PA 物理地址的快速转换                              |

## 8. IO: 设备中断处理程序及中断处理流程 (5')

> (5') 设备中断处理程序通常须完成哪些工作？它对中断进行处理的过程包含哪些步骤？
> 
> _ch07-05-txdsol-p44_

- 设备中断处理程序要完成的工作
	1. **唤醒被阻塞的驱动进程**：当设备完成操作后，唤醒等待该设备的进程。
	2. **保存被中断进程的 CPU 现场信息**：保护当前运行进程的状态，以便后续恢复。
	3. **转入相应的设备处理程序**：根据中断类型调用对应的处理例程。
	4. **处理中断**：执行具体的中断服务，如读取数据、清除中断标志等。
	5. **恢复被中断进程的 CPU 现场**：中断处理完成后，恢复原进程的运行状态。

- 中断处理过程的基本步骤
	1. **测定是否有未响应的中断信号**：由中断控制器检测并确定中断源。
	2. **保护被中断进程的 CPU 现场**：保存当前程序计数器、寄存器等信息。
	3. **转入相应的设备处理程序**：跳转到具体的中断服务程序。
	4. **处理中断**：执行设备相关操作。
	5. **恢复 CPU 现场并退出中断**：恢复原进程状态，继续执行被中断的程序。

![](assets/Pasted%20image%2020250531191451.png)

---

![](assets/Pasted%20image%2020250529113052.png)

第一步不同，对于设备中断处理程序而言，第一步要**唤醒被阻塞的驱动进程**，而对于中断处理过程而言，第一步是要**测定是否有未响应的中断信号**。第二步和最后一步相同，分别是**保护被中断进程的CPU现场**、**恢复被中断进程的CPU现场**并退出中断（针对中断处理过程而言）。第三步、第四步则完全一样，是**转入相应的设备处理程序**和**处理中断**。

---

[https://niuxintao.github.io/assets/pdf/2025Spring-OS/13.[%E6%8C%81%E4%B9%85%E5%8C%96]%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.pdf](https://niuxintao.github.io/assets/pdf/2025Spring-OS/13.[%E6%8C%81%E4%B9%85%E5%8C%96]%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.pdf)

![](assets/Pasted%20image%2020250604160600.png)

### 总结

| 项目           | 说明                                            |
| ------------ | --------------------------------------------- |
| **中断处理程序职责** | **唤醒进程**、保存现场、调用处理程序、处理中断、恢复现场                |
| **处理步骤**     | **检测中断** → 保存现场 → 调用处理程序 → 处理中断 → 恢复现场**并返回** |

**结论**：设备中断处理程序的主要作用是**在不影响当前进程执行的前提下，响应并处理设备的请求**，通过“保存-处理-恢复”的机制完成中断的全过程。

## 9. FS: 文件的逻辑结构与组织形式 (3‘) *

> (3') 什么是文件的逻辑结构？逻辑文件有哪几种组织形式？
> 
> _ch08-04-txdsol-p50_

- **文件的逻辑结构（文件组织）**：用户视角下的的文件组织形式，即**用户可以直接处理的数据及其结构**，它独立于文件的物理特性，不关注OS底层如何存储。
	1. **无结构**文件（**流式**文件）：由**字符流/字节流**构成的文件。
		- 文件信息仅是一串字符或字节的集合，无固定的结构，适合连读读写，如 `.txt` 文件。
	2. **有结构**文件（**记录式**文件）：由**若干记录**构成的文件。
		- 文件被划分为若干**逻辑上独立的信息单位**，每个单位称为一个**记录**，具有独立意义，适合数据库或表格类数据的存储与处理。

**总结**：文件的逻辑结构从**用户**角度反映文件内容的组织形式，分为**无结构的流式文件**和**有结构的记录式文件**两类。

---

![](assets/Pasted%20image%2020250529112836.png)












